## Process

---

프로세스가 실행되면 독자적인 주소 공간을 만든다.

프로세스가 CPU를 잡게되면 PC레지스터가 코드 어느 부분을 가르키고있고 

기계어를 하나씩 읽어서 씨피유에 불러들여 연산을 한 다음 그 결과를 레지스터나 메모리에 저장을 한다.

## 프로세스의 문맥(context)

---

- 프로세스의 모든 상태를 나타내는것

- 하드웨어 문맥 : 프로세스가 인스트럭션을 어디까지 실행했는가를 파악

- 프로세스의 주소공간 : 주소 공간에 어떤 내용이 들어있는가

- 프로세스 관련 자료구조 : 운영체제는 프로세스마다 커널의 주소 공간에PCB(process control block를 두어 프로세스를 관리한다

cpu는 한 프로세스가 계속 점유하는것이 아니라 스케쥴에 따라 돌아가며 사용하기 때문에 

어디까지, 어떤 상태였는지 기록을 하고 있어야한다.

- 프로세스의 상태
  
  - reunning: cpu를 잡고 인스트럭션을 수행중인 상태
  
  - ready : 메모리에 올라와서 cpu를 기다리는 상태 
  
  - blocked(waiting) : 당장 인스트럭션을 수행할 수 없는 상태, 
    
    예) I/O 작업 결과를 기다리는 상태

## PCB(Process Control Block)

---

운영체제가 프로세스를 관리하기 위해 유지하는 정보

- 관리 정보

- 수행 관련 하드웨어 정보

- 메모리 정보

- 파일 정보

## 문맥 교환 (Context switch)

---

프로세스가 CPU를 빼앗길때 현재 진행 정보를 PCB에 저장

새 프로세스가 CPU에 오면 PCB에서 이전 진행 정보를 가져와서 연산을 수행

시스템 콜이나 인터럽트가 발생시 반드시 문맥교환이 되는건 아님

- 시스템콜이나 인터럽트가 오면 커널모드로 운영체제에게 cpu권한이 넘어감 커널이 작업을 수행하고 다시 사용자 모드로 돌아온다 << 문맥 교환이 아니고 모드전환만 된것

## 스케쥴러

---

- Long - term scheduler
  
  - ready queue에 보낼 프로세스를 결정
  
  - 수행해야할 프로세스들 중에서 어떤것을, 몇개를 메모리에 올려서 대기시킬지 결정

- Short - term scheduler
  
  - running 시킬 프로세스를 결정
  
  - 메모리에 올라와 있는 프로세스들 중에 어느것을 CPU에 올려서 연산을 할지 결정

- Medium - Term Scheduler
  
  - 프로세스를 메모리에서 디스크로 옮김
  
  - long term scheduler에 의해서 메모리에 올라왔지만 다른 프로세스들에 비해 그 수행빈도가 작을경우 계속 메모리에 있는것은 효율적이지 못하기 때문에 다시 디스크로 내리는것

## Thread

---

- 프로세스에 CPU 수행단위를 여러개 두는것, 프로세스가 실행되는 흐름의 단위

- task : 같은 프로세스의 쓰레드는 메모리 주소와 상태를 공유 

- 레지스터, 스택, PC는 각자 별개로 가진다.

- 다중 스레드로 구성된 프로세스의 경우 하나의 스레드가 blocked가 되어도 다른 스레드는 계속 동작중이기 때문에 성능이 좋다. (병렬성 높음)

- 프로세스를 여러개 만들면 프로세스들은 각자 메모리 공간을 가지기 때문에 메모리 관리가 비효율적이게 된다.

- 하나의 프로세스 안에 스레드만 여러개 두게 되면 같은 메모리 공간을 공유하기 때문에 효율적이다.
